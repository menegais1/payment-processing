using Microsoft.EntityFrameworkCore;
using PaymentProcessing.Database;
using PaymentProcessing.Schemas;

namespace PaymentProcessing;

public class TransactionRepository : ITransactionRepository, IAsyncDisposable
{
    private readonly PaymentProcessingContext _context;

    public TransactionRepository(PaymentProcessingContext context)
    {
        _context = context;
    }

    public async Task<Transaction> SaveTransaction(TransactionSave transactionSave)
    {
        var newTransaction = new Transaction()
        {
            Id = Guid.NewGuid(), // This could be generated by the DB
            PayeeAccount = transactionSave.PayeeAccount,
            PayerAccount = transactionSave.PayerAccount,
            Amount = transactionSave.Amount,
            Fee = transactionSave.Fee,
            CreatedAt = DateTime.UtcNow, // This could be generated by the DB
            Description = transactionSave.Description,
            CustomerKey = transactionSave.CustomerKey,
            OrganizationId = transactionSave.OrganizationId
        };

        var transaction = await _context.AddAsync(newTransaction);
        await _context.SaveChangesAsync();
        return transaction.Entity;
    }

    public async Task<Transaction?> GetTransaction(Guid transactionId)
    {
        return await _context.Transactions.FindAsync(transactionId);
    }

    public async Task<Transaction?> GetTransactionByCustomerKey(string customerKey)
    {
        return await _context.Transactions.Where(t => t.CustomerKey == customerKey).FirstOrDefaultAsync();
    }

    public async Task<Transaction> UpdateTransaction(Guid transactionId, TransactionUpdate transactionUpdate)
    {
        var transaction = await GetTransaction(transactionId);
        if (transaction != null)
        {
            transaction.Status = transactionUpdate.Status ?? transaction.Status;
            transaction.ApprovedAt = transactionUpdate.ApprovedAt ?? transaction.ApprovedAt;
            transaction.CancelledAt = transactionUpdate.CancelledAt ?? transaction.CancelledAt;
            transaction.FailedAt = transactionUpdate.FailedAt ?? transaction.FailedAt;
            await _context.SaveChangesAsync();
        }
        else
        {
            throw new TransactionNotFoundException(transactionId);
        }

        return transaction;
    }

    public void Dispose()
    {
        _context.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }
}